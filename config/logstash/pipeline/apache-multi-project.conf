input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # fingerprint opzionale
  fingerprint {
    source  => ["message"]
    target  => "[@metadata][fingerprint]"
    method  => "SHA256"
  }

  # ----------------------------------------------------------------------------
  # ACCESS LOG
  # ----------------------------------------------------------------------------
  if [log_type] == "access" {
    # 1) Grok base: COMBINEDAPACHELOG crea: clientip, ident, auth, timestamp, verb, request, httpversion, response, bytes, referrer, agent
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
      tag_on_failure => ["_grok_access_fail"]
    }

    # 2) Timestamp -> @timestamp
    date {
      match  => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
      # timezone giÃ  incluso in Z
    }

    # 3) Split di request in path e query (es. GET /foo/bar?x=1&y=2 HTTP/1.1)
    grok {
      match => {
        "message" => "\[%{HTTPDATE:timestamp}\] \[%{LOGLEVEL:loglevel}\]( \[pid %{INT:pid}\])?( \[tid %{INT:tid}\])?( \[client %{IPORHOST:clientip}:%{INT:clientport}\])?( \[%{DATA:error_type}\])? %{GREEDYDATA:error_message}"
      }
    }
    
    # Parse timestamp for error logs
    date {
      match => [ "timestamp", "EEE MMM dd HH:mm:ss.SSSSSS yyyy" ]
      target => "@timestamp"
    }
    
    # Extract additional error details with more specific patterns
    if [error_message] {
      # Parse PHP errors
      if [error_message] =~ /PHP (?:Fatal error|Parse error|Warning|Notice|Deprecated):/ {
        grok {
          match => {
            "error_message" => "PHP %{WORD:php_error_type}: %{GREEDYDATA:php_error_detail}"
          }
          tag_on_failure => []
        }
      }
      
      # Parse SSL/TLS errors
      if [error_message] =~ /SSL|TLS|certificate/ {
        grok {
          match => {
            "error_message" => "%{GREEDYDATA:ssl_error_detail}"
          }
          tag_on_failure => []
        }
      }
      
      # Parse permission errors
      if [error_message] =~ /Permission denied|Forbidden/ {
        mutate {
          add_field => { "error_category" => "permission" }
        }
      }
      
      # Parse file not found errors
      if [error_message] =~ /File does not exist|No such file/ {
        mutate {
          add_field => { "error_category" => "file_not_found" }
        }
      }
      
      # Extract file paths from error messages
      grok {
        match => {
          "error_message" => "%{UNIXPATH:error_file_path}"
        }
        tag_on_failure => []
      }
      
      # Extract line numbers from error messages
      grok {
        match => {
          "error_message" => ".*line %{INT:error_line_number}.*"
        }
        tag_on_failure => []
      }
    }
    
    # Convert numeric fields
    mutate {
      convert => { 
        "pid" => "integer"
        "tid" => "integer" 
        "clientport" => "integer"
        "error_line_number" => "integer"
      }
      remove_field => ["timestamp"]  # Remove original timestamp field after parsing
    }
    
    # Add error severity based on log level
    if [loglevel] {
      mutate {
        add_field => { 
          "error_severity" => "%{loglevel}"
        }
      }
    }

    # 4) Mapping ECS
    mutate {
      rename => {
        "clientip"            => "[client][ip]"
        "verb"                => "[http][request][method]"
        "response"            => "[http][response][status_code]"
        "bytes"               => "[http][response][bytes]"
        "referrer"            => "[url][referrer]"
        "agent"               => "[user_agent][original]"
        "url_path"            => "[url][path]"
        "url_query"           => "[url][query]"
        "httpversion"         => "[http][version]"
      }
      add_field => {
        "[event][dataset]"     => "apache.access"
        "[event][module]"      => "apache"
        "[event][original]"    => "%{message}"
      }
      convert => {
        "[http][response][status_code]" => "integer"
        "[http][response][bytes]"       => "integer"
      }
    }

    # 5) GeoIP (ECS)
    #geoip {
    #  source            => "[client][ip]"
    #  target            => "[client][geo]"
    #  database          => "/usr/share/GeoIP/GeoLite2-City.mmdb"
    #  ecs_compatibility => "v8"
    #}

    # 6) User Agent (ECS)
    useragent {
      source            => "[user_agent][original]"
      target            => "[user_agent]"
      ecs_compatibility => "v8"
    }

    # 7) Pulizia opzionale
    mutate {
      remove_field => ["ident","auth","timestamp","request"]
    }
  }

  # ----------------------------------------------------------------------------
  # ERROR LOG
  # ----------------------------------------------------------------------------
  if [log_type] == "error" {
    # Esempi Apache 2.4:
    # [Tue Sep 30 10:07:16.123456 2025] [php7:warn] [pid 1234:tid 140735] [client 1.2.3.4:55555] AH01234: message text...
    # [Tue Sep 30 10:07:16.123456 2025] [mpm_event:notice] [pid 1234:tid 5678] AH00094: Command line: ...
    grok {
      match => {
        "message" => [
          # con client ip/port
          "^\[%{HTTPDATE:apache.error.timestamp}\] \[(?<log.logger>[^:\]]+):%{LOGLEVEL:log.level}\](?: \[pid %{NUMBER:process.pid}(?::tid %{NUMBER:process.thread.id})?\])?(?: \[client %{IPORHOST:[client][ip]}(?::%{NUMBER:[client][port]})?\])?\s*(?:AH%{NUMBER:apache.error.code}:\s*)?(?<apache.error.message>.*)$",
          # senza client
          "^\[%{HTTPDATE:apache.error.timestamp}\] \[(?<log.logger>[^:\]]+):%{LOGLEVEL:log.level}\](?: \[pid %{NUMBER:process.pid}(?::tid %{NUMBER:process.thread.id})?\])?\s*(?:AH%{NUMBER:apache.error.code}:\s*)?(?<apache.error.message>.*)$"
        ]
      }
      tag_on_failure => ["_grok_error_fail"]
    }

    # timestamp -> @timestamp
    date {
      match  => [ "apache.error.timestamp", "EEE MMM dd HH:mm:ss.SSSSSS yyyy", "EEE MMM dd HH:mm:ss yyyy" ]
      target => "@timestamp"
    }

    mutate {
      add_field => {
        "[event][dataset]"  => "apache.error"
        "[event][module]"   => "apache"
        "[event][original]" => "%{message}"
      }
      rename => { "apache.error.message" => "message" }
    }
  }

  # ----------------------------------------------------------------------------
  # Index naming con project (se lo mandi da Filebeat con add_fields)
  # ----------------------------------------------------------------------------
  mutate {
    add_field => {
      "[@metadata][target_index]" => "apache-%{[project]}-%{+YYYY.MM.dd}"
    }
  }
}

output {
  elasticsearch {
    hosts           => ["elasticsearch:9200"]
    user            => "${ELASTICSEARCH_USERNAME}"
    password        => "${ELASTICSEARCH_PASSWORD}"
    index           => "%{[@metadata][target_index]}"
    manage_template => true
    template_name   => "apache-logs"
    document_id   => "%{[@metadata][fingerprint]}"  # se vuoi de-duplicare
  }

  stdout { codec => rubydebug { metadata => true } }
}
