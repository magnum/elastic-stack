input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # fingerprint opzionale
  fingerprint {
    source  => ["message"]
    target  => "[@metadata][fingerprint]"
    method  => "SHA256"
  }

  # ----------------------------------------------------------------------------
  # ROUTING BASED ON LOG TYPE
  # ----------------------------------------------------------------------------
  
  # Apache Access Logs
  if [log_type] == "apache_access" {
    
    # 1) Grok base: COMBINEDAPACHELOG crea: clientip, ident, auth, timestamp, verb, request, httpversion, response, bytes, referrer, agent
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
      tag_on_failure => ["_grok_access_fail"]
    }

    # 2) Timestamp -> @timestamp
    date {
      match  => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
    }

    # 3) Split di request in path e query (es. GET /foo/bar?x=1&y=2 HTTP/1.1)
    grok {
      match => {
        "request" => "%{WORD:verb} %{URIPATH:url_path}(?:%{URIPARAM:url_query})? %{DATA:httpversion}"
      }
      tag_on_failure => []
    }

    # 4) Mapping ECS
    mutate {
      rename => {
        "clientip"            => "[client][ip]"
        "verb"                => "[http][request][method]"
        "response"            => "[http][response][status_code]"
        "bytes"               => "[http][response][bytes]"
        "referrer"            => "[url][referrer]"
        "agent"               => "[user_agent][original]"
        "url_path"            => "[url][path]"
        "url_query"           => "[url][query]"
        "httpversion"         => "[http][version]"
      }
      add_field => {
        "[event][dataset]"     => "apache.access"
        "[event][module]"      => "apache"
        "[event][original]"    => "%{message}"
      }
      convert => {
        "[http][response][status_code]" => "integer"
        "[http][response][bytes]"       => "integer"
      }
    }

    # 5) User Agent (ECS)
    useragent {
      source            => "[user_agent][original]"
      target            => "[user_agent]"
      ecs_compatibility => "v8"
    }

    # 6) Pulizia
    mutate {
      remove_field => ["ident","auth","timestamp","request"]
      add_field => {
        "[@metadata][target_index]" => "apache-access-%{[project]}-%{+YYYY.MM.dd}"
      }
    }
  }
  
  # Apache Error Logs
  if [log_type] == "apache_error" {
    
    # Esempi Apache 2.4:
    # [Tue Sep 30 10:07:16.123456 2025] [php7:warn] [pid 1234:tid 140735] [client 1.2.3.4:55555] AH01234: message text...
    grok {
      match => {
        "message" => [
          # con client ip/port
          "^\[%{HTTPDATE:apache.error.timestamp}\] \[(?<log.logger>[^:\]]+):%{LOGLEVEL:log.level}\](?: \[pid %{NUMBER:process.pid}(?::tid %{NUMBER:process.thread.id})?\])?(?: \[client %{IPORHOST:[client][ip]}(?::%{NUMBER:[client][port]})?\])?\s*(?:AH%{NUMBER:apache.error.code}:\s*)?(?<apache.error.message>.*)$",
          # senza client
          "^\[%{HTTPDATE:apache.error.timestamp}\] \[(?<log.logger>[^:\]]+):%{LOGLEVEL:log.level}\](?: \[pid %{NUMBER:process.pid}(?::tid %{NUMBER:process.thread.id})?\])?\s*(?:AH%{NUMBER:apache.error.code}:\s*)?(?<apache.error.message>.*)$"
        ]
      }
      tag_on_failure => ["_grok_error_fail"]
    }

    # timestamp -> @timestamp
    date {
      match  => [ "apache.error.timestamp", "EEE MMM dd HH:mm:ss.SSSSSS yyyy", "EEE MMM dd HH:mm:ss yyyy" ]
      target => "@timestamp"
    }

    # ECS mapping per Apache errors
    mutate {
      add_field => {
        "[event][dataset]"  => "apache.error"
        "[event][module]"   => "apache"
        "[event][original]" => "%{message}"
        "[event][severity]" => "%{log.level}"
      }
      rename => { 
        "apache.error.message" => "[error][message]"
        "apache.error.code"    => "[error][code]"
      }
      convert => {
        "process.pid"         => "integer"
        "process.thread.id"   => "integer"
        "[client][port]"      => "integer"
        "[error][code]"       => "integer"
      }
      remove_field => ["apache.error.timestamp"]
    }

    # Extract file path and line number from Apache error messages (when present)
    if [error][message] {
      # Extract file paths from error messages
      grok {
        match => {
          "[error][message]" => [
            # Pattern per file path con line number
            "%{GREEDYDATA} in %{UNIXPATH:apache.error.file} on line %{INT:apache.error.line}",
            # Pattern per file path senza line number  
            "%{GREEDYDATA} in %{UNIXPATH:apache.error.file}",
            # Pattern per configurazione files
            "%{GREEDYDATA} file %{UNIXPATH:apache.error.file}",
            # Pattern per script files
            "%{GREEDYDATA} script %{UNIXPATH:apache.error.file}"
          ]
        }
        tag_on_failure => []
      }
      
      # Convert and rename extracted fields
      mutate {
        rename => {
          "apache.error.file" => "[error][file][path]"
          "apache.error.line" => "[error][line][number]"
        }
        convert => {
          "[error][line][number]" => "integer"
        }
      }
      
      # Extract directory and filename if file path exists
      if [error][file][path] {
        grok {
          match => {
            "[error][file][path]" => "^(?<apache.error.dir>/.*/)(?<apache.error.filename>[^/]+)$"
          }
          tag_on_failure => []
        }
        
        mutate {
          rename => {
            "apache.error.dir"      => "[error][file][directory]"
            "apache.error.filename" => "[error][file][name]"
          }
        }
      }
    }

    mutate {
      add_field => {
        "[@metadata][target_index]" => "apache-error-%{[project]}-%{+YYYY.MM.dd}"
      }
    }
  }
  
  # PHP Error Logs
  if [log_type] == "php_error" {
    
    # Esempi PHP error log:
    # [30-Sep-2025 10:07:16 UTC] PHP Warning:  include_once(/path/to/file.php): failed to open stream: No such file or directory in /var/www/html/index.php on line 123
    grok {
      match => {
        "message" => [
          # Con timezone
          "^\[%{DATA:php.error.timestamp} %{DATA:php.error.timezone}\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message} in %{UNIXPATH:php.error.file} on line %{INT:php.error.line}(?:, referer: %{DATA:php.error.referer})?$",
          # Senza timezone
          "^\[%{DATA:php.error.timestamp}\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message} in %{UNIXPATH:php.error.file} on line %{INT:php.error.line}(?:, referer: %{DATA:php.error.referer})?$",
          # Solo messaggio base (fallback)
          "^\[%{DATA:php.error.timestamp}(?:\s+%{DATA:php.error.timezone})?\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message}$"
        ]
      }
      tag_on_failure => ["_grok_php_error_fail"]
    }

    # Parse timestamp PHP error logs
    date {
      match  => [ 
        "php.error.timestamp", 
        "dd-MMM-yyyy HH:mm:ss", 
        "yyyy-MM-dd HH:mm:ss",
        "MMM dd HH:mm:ss yyyy"
      ]
      target => "@timestamp"
    }

    # ECS mapping per PHP errors
    mutate {
      add_field => {
        "[event][dataset]"   => "php.error"
        "[event][module]"    => "php"
        "[event][original]"  => "%{message}"
        "[event][severity]"  => "%{php.error.level}"
      }
      rename => {
        "php.error.level"    => "[log][level]"
        "php.error.message"  => "[error][message]"
        "php.error.file"     => "[error][file][path]"
        "php.error.line"     => "[error][line][number]"
        "php.error.referer"  => "[http][request][referrer]"
      }
      convert => {
        "[error][line][number]" => "integer"
      }
      remove_field => ["php.error.timestamp", "php.error.timezone"]
    }

    # Extract additional PHP error details
    if [error][message] {
      # Parse specific error types
      if [log][level] == "Fatal error" {
        mutate {
          add_field => { "[error][type]" => "fatal" }
        }
        
        # Extract function calls from fatal errors
        if [error][message] =~ /Call to undefined function/ {
          grok {
            match => {
              "[error][message]" => "Call to undefined function %{DATA:php.error.undefined_function}\\(\\)"
            }
            tag_on_failure => []
          }
          mutate {
            add_field => { "[error][category]" => "undefined_function" }
          }
        }
        
        # Extract class issues
        if [error][message] =~ /Class.*not found/ {
          grok {
            match => {
              "[error][message]" => "Class '%{DATA:php.error.undefined_class}' not found"
            }
            tag_on_failure => []
          }
          mutate {
            add_field => { "[error][category]" => "undefined_class" }
          }
        }
      }
      
      if [log][level] == "Parse error" {
        mutate {
          add_field => { 
            "[error][type]" => "parse"
            "[error][category]" => "syntax"
          }
        }
        
        # Extract syntax error details
        grok {
          match => {
            "[error][message]" => "syntax error, %{GREEDYDATA:php.error.syntax_detail}"
          }
          tag_on_failure => []
        }
      }
      
      if [log][level] == "Warning" {
        mutate {
          add_field => { "[error][type]" => "warning" }
        }
        
        # File system warnings
        if [error][message] =~ /failed to open stream|No such file/ {
          mutate {
            add_field => { "[error][category]" => "file_not_found" }
          }
        }
        
        # Include/include_once warnings
        if [error][message] =~ /include|require/ {
          mutate {
            add_field => { "[error][category]" => "include_error" }
          }
        }
      }
      
      if [log][level] == "Notice" {
        mutate {
          add_field => { 
            "[error][type]" => "notice"
            "[error][category]" => "undefined_variable"
          }
        }
        
        # Extract undefined variable names
        grok {
          match => {
            "[error][message]" => "Undefined variable: %{DATA:php.error.undefined_variable}"
          }
          tag_on_failure => []
        }
      }
      
      if [log][level] == "Deprecated" {
        mutate {
          add_field => { 
            "[error][type]" => "deprecated"
            "[error][category]" => "deprecated_function"
          }
        }
        
        # Extract deprecated function names
        grok {
          match => {
            "[error][message]" => "%{DATA:php.error.deprecated_function}\\(\\) is deprecated"
          }
          tag_on_failure => []
        }
      }
    }

    # Extract file information
    if [error][file][path] {
      # Extract directory path
      grok {
        match => {
          "[error][file][path]" => "^(?<php.error.dir>/.*/)(?<php.error.filename>[^/]+)$"
        }
        tag_on_failure => []
      }
      
      mutate {
        rename => {
          "php.error.dir"      => "[error][file][directory]"
          "php.error.filename" => "[error][file][name]"
        }
      }
    }

    mutate {
      add_field => {
        "[@metadata][target_index]" => "php-error-%{[project]}-%{+YYYY.MM.dd}"
      }
    }
  }
}

output {
  elasticsearch {
    hosts           => ["elasticsearch:9200"]
    user            => "${ELASTICSEARCH_USERNAME}"
    password        => "${ELASTICSEARCH_PASSWORD}"
    index           => "%{[@metadata][target_index]}"
    manage_template => true
    template_name   => "logs"
    document_id     => "%{[@metadata][fingerprint]}"
  }

  stdout { codec => rubydebug { metadata => true } }
}