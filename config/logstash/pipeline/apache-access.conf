input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # fingerprint opzionale
  fingerprint {
    source  => ["message"]
    target  => "[@metadata][fingerprint]"
    method  => "SHA256"
  }


  # 1) Grok base: COMBINEDAPACHELOG crea: clientip, ident, auth, timestamp, verb, request, httpversion, response, bytes, referrer, agent
  grok {
    match => { "message" => "%{COMBINEDAPACHELOG}" }
    tag_on_failure => ["_grok_access_fail"]
  }

  # 2) Timestamp -> @timestamp
  date {
    match  => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
    # timezone giÃ  incluso in Z
  }

  # 3) Split di request in path e query (es. GET /foo/bar?x=1&y=2 HTTP/1.1)
  grok {
    match => {
      "message" => "\[%{HTTPDATE:timestamp}\] \[%{LOGLEVEL:loglevel}\]( \[pid %{INT:pid}\])?( \[tid %{INT:tid}\])?( \[client %{IPORHOST:clientip}:%{INT:clientport}\])?( \[%{DATA:error_type}\])? %{GREEDYDATA:error_message}"
    }
  }
  
  # Parse timestamp for error logs
  date {
    match => [ "timestamp", "EEE MMM dd HH:mm:ss.SSSSSS yyyy" ]
    target => "@timestamp"
  }
  
  # Extract additional error details with more specific patterns
  if [error_message] {
    # Parse PHP errors
    if [error_message] =~ /PHP (?:Fatal error|Parse error|Warning|Notice|Deprecated):/ {
      grok {
        match => {
          "error_message" => "PHP %{WORD:php_error_type}: %{GREEDYDATA:php_error_detail}"
        }
        tag_on_failure => []
      }
    }
    
    # Parse SSL/TLS errors
    if [error_message] =~ /SSL|TLS|certificate/ {
      grok {
        match => {
          "error_message" => "%{GREEDYDATA:ssl_error_detail}"
        }
        tag_on_failure => []
      }
    }
    
    # Parse permission errors
    if [error_message] =~ /Permission denied|Forbidden/ {
      mutate {
        add_field => { "error_category" => "permission" }
      }
    }
    
    # Parse file not found errors
    if [error_message] =~ /File does not exist|No such file/ {
      mutate {
        add_field => { "error_category" => "file_not_found" }
      }
    }
    
    # Extract file paths from error messages
    grok {
      match => {
        "error_message" => "%{UNIXPATH:error_file_path}"
      }
      tag_on_failure => []
    }
    
    # Extract line numbers from error messages
    grok {
      match => {
        "error_message" => ".*line %{INT:error_line_number}.*"
      }
      tag_on_failure => []
    }
  }
  
  # Convert numeric fields
  mutate {
    convert => { 
      "pid" => "integer"
      "tid" => "integer" 
      "clientport" => "integer"
      "error_line_number" => "integer"
    }
    remove_field => ["timestamp"]  # Remove original timestamp field after parsing
  }
  
  # Add error severity based on log level
  if [loglevel] {
    mutate {
      add_field => { 
        "error_severity" => "%{loglevel}"
      }
    }
  }

  # 4) Mapping ECS
  mutate {
    rename => {
      "clientip"            => "[client][ip]"
      "verb"                => "[http][request][method]"
      "response"            => "[http][response][status_code]"
      "bytes"               => "[http][response][bytes]"
      "referrer"            => "[url][referrer]"
      "agent"               => "[user_agent][original]"
      "url_path"            => "[url][path]"
      "url_query"           => "[url][query]"
      "httpversion"         => "[http][version]"
    }
    add_field => {
      "[event][dataset]"     => "apache.access"
      "[event][module]"      => "apache"
      "[event][original]"    => "%{message}"
    }
    convert => {
      "[http][response][status_code]" => "integer"
      "[http][response][bytes]"       => "integer"
    }
  }

  # 5) GeoIP (ECS)
  #geoip {
  #  source            => "[client][ip]"
  #  target            => "[client][geo]"
  #  database          => "/usr/share/GeoIP/GeoLite2-City.mmdb"
  #  ecs_compatibility => "v8"
  #}

  # 6) User Agent (ECS)
  useragent {
    source            => "[user_agent][original]"
    target            => "[user_agent]"
    ecs_compatibility => "v8"
  }

  # 7) Pulizia opzionale
  mutate {
    remove_field => ["ident","auth","timestamp","request"]
  }

  # ----------------------------------------------------------------------------
  # Index naming con project (se lo mandi da Filebeat con add_fields)
  # ----------------------------------------------------------------------------
  mutate {
    add_field => {
      "[@metadata][target_index]" => "apache-%{[project]}-%{+YYYY.MM.dd}"
    }
  }
}

output {
  elasticsearch {
    hosts           => ["elasticsearch:9200"]
    user            => "${ELASTICSEARCH_USERNAME}"
    password        => "${ELASTICSEARCH_PASSWORD}"
    index           => "%{[@metadata][target_index]}"
    manage_template => true
    template_name   => "apache-logs"
    document_id   => "%{[@metadata][fingerprint]}"  # se vuoi de-duplicare
  }

  stdout { codec => rubydebug { metadata => true } }
}
