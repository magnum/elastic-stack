input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # fingerprint opzionale
  fingerprint {
    source  => ["message"]
    target  => "[@metadata][fingerprint]"
    method  => "SHA256"
  }

  # ----------------------------------------------------------------------------
  # APACHE ACCESS LOGS
  # ----------------------------------------------------------------------------
  # 1) Grok base: COMBINEDAPACHELOG crea: clientip, ident, auth, timestamp, verb, request, httpversion, response, bytes, referrer, agent
  grok {
    match => { "message" => "%{COMBINEDAPACHELOG}" }
    tag_on_failure => ["_grok_access_fail"]
  }

  # 2) Timestamp -> @timestamp
  date {
    match  => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
    # timezone giÃ  incluso in Z
  }

  # 3) Split di request in path e query (es. GET /foo/bar?x=1&y=2 HTTP/1.1)
  grok {
    match => {
      "request" => "%{WORD:verb} %{URIPATH:url_path}(?:%{URIPARAM:url_query})? %{DATA:httpversion}"
    }
    tag_on_failure => []
  }

  # 4) Mapping ECS
  mutate {
    rename => {
      "clientip"            => "[client][ip]"
      "verb"                => "[http][request][method]"
      "response"            => "[http][response][status_code]"
      "bytes"               => "[http][response][bytes]"
      "referrer"            => "[url][referrer]"
      "agent"               => "[user_agent][original]"
      "url_path"            => "[url][path]"
      "url_query"           => "[url][query]"
      "httpversion"         => "[http][version]"
    }
    add_field => {
      "[event][dataset]"     => "apache.access"
      "[event][module]"      => "apache"
      "[event][original]"    => "%{message}"
    }
    convert => {
      "[http][response][status_code]" => "integer"
      "[http][response][bytes]"       => "integer"
    }
  }

  # 5) GeoIP (ECS) - opzionale
  #geoip {
  #  source            => "[client][ip]"
  #  target            => "[client][geo]"
  #  database          => "/usr/share/GeoIP/GeoLite2-City.mmdb"
  #  ecs_compatibility => "v8"
  #}

  # 6) User Agent (ECS)
  useragent {
    source            => "[user_agent][original]"
    target            => "[user_agent]"
    ecs_compatibility => "v8"
  }

  # 7) Pulizia opzionale
  mutate {
    remove_field => ["ident","auth","timestamp","request"]
  }

  # ----------------------------------------------------------------------------
  # Index naming con project
  # ----------------------------------------------------------------------------
  mutate {
    add_field => {
      "[@metadata][target_index]" => "apache-access-%{[project]}-%{+YYYY.MM.dd}"
    }
  }
}

output {
  elasticsearch {
    hosts           => ["elasticsearch:9200"]
    user            => "${ELASTICSEARCH_USERNAME}"
    password        => "${ELASTICSEARCH_PASSWORD}"
    index           => "%{[@metadata][target_index]}"
    manage_template => true
    template_name   => "apache-access-logs"
    document_id     => "%{[@metadata][fingerprint]}"
  }

  stdout { codec => rubydebug { metadata => true } }
}