input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # fingerprint opzionale
  fingerprint {
    source  => ["message"]
    target  => "[@metadata][fingerprint]"
    method  => "SHA256"
  }

  # ----------------------------------------------------------------------------
  # PHP ERROR LOGS
  # ----------------------------------------------------------------------------
  # Processa solo log di tipo php_error
  if [log_type] == "php_error" {
    
    # Esempi PHP error log:
    # [30-Sep-2025 10:07:16 UTC] PHP Warning:  include_once(/path/to/file.php): failed to open stream: No such file or directory in /var/www/html/index.php on line 123
    grok {
      match => {
        "message" => [
          # Con timezone
          "^\[%{DATA:php.error.timestamp} %{DATA:php.error.timezone}\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message} in %{UNIXPATH:php.error.file} on line %{INT:php.error.line}(?:, referer: %{DATA:php.error.referer})?$",
          # Senza timezone
          "^\[%{DATA:php.error.timestamp}\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message} in %{UNIXPATH:php.error.file} on line %{INT:php.error.line}(?:, referer: %{DATA:php.error.referer})?$",
          # Solo messaggio base (fallback)
          "^\[%{DATA:php.error.timestamp}(?:\s+%{DATA:php.error.timezone})?\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message}$"
        ]
      }
      tag_on_failure => ["_grok_php_error_fail"]
    }

    # Parse timestamp PHP error logs
    date {
      match  => [ 
        "php.error.timestamp", 
        "dd-MMM-yyyy HH:mm:ss", 
        "yyyy-MM-dd HH:mm:ss",
        "MMM dd HH:mm:ss yyyy"
      ]
      target => "@timestamp"
    }

    # ECS mapping per PHP errors
    mutate {
      add_field => {
        "[event][dataset]"   => "php.error"
        "[event][module]"    => "php"
        "[event][original]"  => "%{message}"
        "[event][severity]"  => "%{php.error.level}"
      }
      rename => {
        "php.error.level"    => "[log][level]"
        "php.error.message"  => "[error][message]"
        "php.error.file"     => "[error][file][path]"
        "php.error.line"     => "[error][line][number]"
        "php.error.referer"  => "[http][request][referrer]"
      }
      convert => {
        "[error][line][number]" => "integer"
      }
      remove_field => ["php.error.timestamp", "php.error.timezone"]
    }

    # Extract additional PHP error details
    if [error][message] {
      # Parse specific error types
      if [log][level] == "Fatal error" {
        mutate {
          add_field => { "[error][type]" => "fatal" }
        }
        
        # Extract function calls from fatal errors
        if [error][message] =~ /Call to undefined function/ {
          grok {
            match => {
              "[error][message]" => "Call to undefined function %{DATA:php.error.undefined_function}\\(\\)"
            }
            tag_on_failure => []
          }
          mutate {
            add_field => { "[error][category]" => "undefined_function" }
          }
        }
        
        # Extract class issues
        if [error][message] =~ /Class.*not found/ {
          grok {
            match => {
              "[error][message]" => "Class '%{DATA:php.error.undefined_class}' not found"
            }
            tag_on_failure => []
          }
          mutate {
            add_field => { "[error][category]" => "undefined_class" }
          }
        }
      }
      
      elsif [log][level] == "Parse error" {
        mutate {
          add_field => { 
            "[error][type]" => "parse"
            "[error][category]" => "syntax"
          }
        }
        
        # Extract syntax error details
        grok {
          match => {
            "[error][message]" => "syntax error, %{GREEDYDATA:php.error.syntax_detail}"
          }
          tag_on_failure => []
        }
      }
      
      elsif [log][level] == "Warning" {
        mutate {
          add_field => { "[error][type]" => "warning" }
        }
        
        # File system warnings
        if [error][message] =~ /failed to open stream|No such file/ {
          mutate {
            add_field => { "[error][category]" => "file_not_found" }
          }
        }
        
        # Include/include_once warnings
        if [error][message] =~ /include|require/ {
          mutate {
            add_field => { "[error][category]" => "include_error" }
          }
        }
      }
      
      elsif [log][level] == "Notice" {
        mutate {
          add_field => { 
            "[error][type]" => "notice"
            "[error][category]" => "undefined_variable"
          }
        }
        
        # Extract undefined variable names
        grok {
          match => {
            "[error][message]" => "Undefined variable: %{DATA:php.error.undefined_variable}"
          }
          tag_on_failure => []
        }
      }
      
      elsif [log][level] == "Deprecated" {
        mutate {
          add_field => { 
            "[error][type]" => "deprecated"
            "[error][category]" => "deprecated_function"
          }
        }
        
        # Extract deprecated function names
        grok {
          match => {
            "[error][message]" => "%{DATA:php.error.deprecated_function}\\(\\) is deprecated"
          }
          tag_on_failure => []
        }
      }
    }

    # Extract file information
    if [error][file][path] {
      # Extract directory path
      grok {
        match => {
          "[error][file][path]" => "^(?<php.error.dir>/.*/)(?<php.error.filename>[^/]+)$"
        }
        tag_on_failure => []
      }
      
      mutate {
        rename => {
          "php.error.dir"      => "[error][file][directory]"
          "php.error.filename" => "[error][file][name]"
        }
      }
    }

    mutate {
      add_field => {
        "[@metadata][target_index]" => "php-error-%{[project]}-%{+YYYY.MM.dd}"
      }
    }
  }
  # Drop tutti gli altri tipi di log
  else {
    drop { }
  }
}

output {
  elasticsearch {
    hosts           => ["elasticsearch:9200"]
    user            => "${ELASTICSEARCH_USERNAME}"
    password        => "${ELASTICSEARCH_PASSWORD}"
    index           => "%{[@metadata][target_index]}"
    manage_template => true
    template_name   => "php-error-logs"
    document_id     => "%{[@metadata][fingerprint]}"
  }

  stdout { codec => rubydebug { metadata => true } }
}
