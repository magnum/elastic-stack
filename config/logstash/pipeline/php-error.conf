input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # fingerprint opzionale
  fingerprint {
    source  => ["message"]
    target  => "[@metadata][fingerprint]"
    method  => "SHA256"
  }

  # ----------------------------------------------------------------------------
  # PHP ERROR LOGS
  # ----------------------------------------------------------------------------
  # Esempi PHP error log:
  # [30-Sep-2025 10:07:16 UTC] PHP Warning:  include_once(/path/to/file.php): failed to open stream: No such file or directory in /var/www/html/index.php on line 123
  # [30-Sep-2025 10:07:16 Europe/Rome] PHP Fatal error:  Call to undefined function function_name() in /var/www/html/script.php on line 456
  # [30-Sep-2025 10:07:16] PHP Parse error:  syntax error, unexpected '}' in /var/www/html/file.php on line 789
  # [30-Sep-2025 10:07:16] PHP Notice:  Undefined variable: $var in /var/www/html/page.php on line 321
  # [30-Sep-2025 10:07:16] PHP Deprecated:  mysql_connect() is deprecated in /var/www/html/db.php on line 15

  grok {
    match => {
      "message" => [
        # Con timezone
        "^\[%{DATA:php.error.timestamp} %{DATA:php.error.timezone}\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message} in %{UNIXPATH:php.error.file} on line %{INT:php.error.line}(?:, referer: %{DATA:php.error.referer})?$",
        # Senza timezone
        "^\[%{DATA:php.error.timestamp}\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message} in %{UNIXPATH:php.error.file} on line %{INT:php.error.line}(?:, referer: %{DATA:php.error.referer})?$",
        # Solo messaggio base (fallback)
        "^\[%{DATA:php.error.timestamp}(?:\s+%{DATA:php.error.timezone})?\] PHP %{WORD:php.error.level}: %{GREEDYDATA:php.error.message}$"
      ]
    }
    tag_on_failure => ["_grok_php_error_fail"]
  }

  # Parse timestamp PHP error logs
  date {
    match  => [ 
      "php.error.timestamp", 
      "dd-MMM-yyyy HH:mm:ss", 
      "yyyy-MM-dd HH:mm:ss",
      "MMM dd HH:mm:ss yyyy"
    ]
    target => "@timestamp"
  }

  # ECS mapping per PHP errors
  mutate {
    add_field => {
      "[event][dataset]"   => "php.error"
      "[event][module]"    => "php"
      "[event][original]"  => "%{message}"
      "[event][severity]"  => "%{php.error.level}"
    }
    rename => {
      "php.error.level"    => "[log][level]"
      "php.error.message"  => "[error][message]"
      "php.error.file"     => "[error][file][path]"
      "php.error.line"     => "[error][line][number]"
      "php.error.referer"  => "[http][request][referrer]"
    }
    convert => {
      "[error][line][number]" => "integer"
    }
    remove_field => ["php.error.timestamp", "php.error.timezone"]
  }

  # Extract additional PHP error details
  if [error][message] {
    # Parse specific error types
    if [log][level] == "Fatal error" {
      mutate {
        add_field => { "[error][type]" => "fatal" }
      }
      
      # Extract function calls from fatal errors
      if [error][message] =~ /Call to undefined function/ {
        grok {
          match => {
            "[error][message]" => "Call to undefined function %{DATA:php.error.undefined_function}\\(\\)"
          }
          tag_on_failure => []
        }
        mutate {
          add_field => { "[error][category]" => "undefined_function" }
        }
      }
      
      # Extract class issues
      if [error][message] =~ /Class.*not found/ {
        grok {
          match => {
            "[error][message]" => "Class '%{DATA:php.error.undefined_class}' not found"
          }
          tag_on_failure => []
        }
        mutate {
          add_field => { "[error][category]" => "undefined_class" }
        }
      }
    }
    
    elsif [log][level] == "Parse error" {
      mutate {
        add_field => { 
          "[error][type]" => "parse"
          "[error][category]" => "syntax"
        }
      }
      
      # Extract syntax error details
      grok {
        match => {
          "[error][message]" => "syntax error, %{GREEDYDATA:php.error.syntax_detail}"
        }
        tag_on_failure => []
      }
    }
    
    elsif [log][level] == "Warning" {
      mutate {
        add_field => { "[error][type]" => "warning" }
      }
      
      # File system warnings
      if [error][message] =~ /failed to open stream|No such file/ {
        mutate {
          add_field => { "[error][category]" => "file_not_found" }
        }
      }
      
      # Include/include_once warnings
      if [error][message] =~ /include|require/ {
        mutate {
          add_field => { "[error][category]" => "include_error" }
        }
      }
    }
    
    elsif [log][level] == "Notice" {
      mutate {
        add_field => { 
          "[error][type]" => "notice"
          "[error][category]" => "undefined_variable"
        }
      }
      
      # Extract undefined variable names
      grok {
        match => {
          "[error][message]" => "Undefined variable: %{DATA:php.error.undefined_variable}"
        }
        tag_on_failure => []
      }
    }
    
    elsif [log][level] == "Deprecated" {
      mutate {
        add_field => { 
          "[error][type]" => "deprecated"
          "[error][category]" => "deprecated_function"
        }
      }
      
      # Extract deprecated function names
      grok {
        match => {
          "[error][message]" => "%{DATA:php.error.deprecated_function}\\(\\) is deprecated"
        }
        tag_on_failure => []
      }
    }
  }

  # Extract file information
  if [error][file][path] {
    # Extract directory path
    grok {
      match => {
        "[error][file][path]" => "^(?<php.error.dir>/.*/)(?<php.error.filename>[^/]+)$"
      }
      tag_on_failure => []
    }
    
    mutate {
      rename => {
        "php.error.dir"      => "[error][file][directory]"
        "php.error.filename" => "[error][file][name]"
      }
    }
  }

  # Add project-specific metadata
  mutate {
    add_field => {
      "[@metadata][target_index]" => "php-error-%{[project]}-%{+YYYY.MM.dd}"
    }
  }
}

output {
  elasticsearch {
    hosts           => ["elasticsearch:9200"]
    user            => "${ELASTICSEARCH_USERNAME}"
    password        => "${ELASTICSEARCH_PASSWORD}"
    index           => "%{[@metadata][target_index]}"
    manage_template => true
    template_name   => "php-error-logs"
    document_id     => "%{[@metadata][fingerprint]}"
  }

  # Debug output (commenta in produzione)
  stdout { 
    codec => rubydebug { 
      metadata => true 
    } 
  }
}
